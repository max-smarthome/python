"""
1. Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы. Сортировка должна быть реализована в
виде функции. Обязательно доработайте алгоритм (сделайте его умнее).

Идея доработки: если за проход по списку не совершается ни одной сортировки,
то завершение
Обязательно сделайте замеры времени обеих реализаций
и обосновать дала ли оптимизация эффективность

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию
"""
import numpy as np
from random import randint
from timeit import timeit


def bubble(n):
    N = len(n)
    k = 0
    for i in range(N):
        change = False
        for j in range(N - i - 1):
            if n[j] < n[j+1]:
                n[j], n[j+1] = n[j+1], n[j]
            k += 1
#    print(f'Число проходов {k}')
    return n


def bubble_opt(n):
    N = len(n)
    k = 0
    for i in range(N):
        change = False
        for j in range(N - i - 1):
            if n[j] < n[j+1]:
                n[j], n[j+1] = n[j+1], n[j]
                change = True
            k += 1
        if not change:
            break
#    print(f'Число проходов оптимизированного алгоритма {k}')
    return n


arr = [randint(-100, 100) for _ in range(1000)]


#print(bubble(arr[:]))
#print(bubble_opt(arr[:]))


print(timeit("bubble(arr[:])", setup = "from __main__ import bubble, arr", number = 100))
print(timeit("bubble_opt(arr[:])", setup = "from __main__ import bubble_opt, arr", number = 100))

'''
Были проведены два теста: с одним запуском и выводом числа проходов, и с 100 запусками без вывода числа проходов.
Как видно из результатов, оптимизированный алгоритм выполняется быстрее. При росте массива число проходов 
и разница во времени ощущается особенно заметно. Если в массиве из 100 элементов разница в числе проходов меньше 100,
то в массиве с 10000 элементов разница в числе проходов  больше 10000, 
что, конечно, и играет главную роль в уменьшении времени  

На 100 запусках:
16.5335524
11.5212152

На 1 запуске:
Массив 100
Число проходов 4950
0.0018432999999999922
Число проходов оптимизированного алгоритма 4872
0.0017152000000000278

Массив 1000
Число проходов 499500
0.2665044000000001
Число проходов оптимизированного алгоритма 497015
0.2557969000000002

Массив 10000
Число проходов 49995000
16.2280607
Число проходов оптимизированного алгоритма 49967972
12.9182688


'''